#!/local/perl/bin/perl

# ------------------------------------------------------------------
# BsmlScaffolds.pm
#
# Jonathan Crabtree <crabtree@tigr.org>
#
# Created: Thu Aug 12 14:09:40 EDT 2004
# ------------------------------------------------------------------

package BSML::BsmlScaffolds;

use strict;
use File::Spec;

# ------------------------------------------------------------------
# Globals
# ------------------------------------------------------------------

my $NUM_GAP_CHARS = 100;
my $GAP_CHARS = '';
for( my $i=0; $i<$NUM_GAP_CHARS; $i++ ) { $GAP_CHARS .= 'N'; }

# ------------------------------------------------------------------
# Subroutines
# ------------------------------------------------------------------

# Write a set of BSML scaffold files.
#
# $scaffolds - listref of hashes of the following form:
#  { scaff_id => scaffold id
#    data => [ {
#     	'asmbl_id' => asmbl_id - used to retrieve assembly BSML document from BSML_repository,
#	'scaff_id' => scaffold id - used to name created BSML scaffold file,
#	'scaff_order' => ascending integer index indicating contig position in scaffold,
#	'direction' => either 'F' or 'R' for forward or reverse,
#	'gap_mean' => mean gap size (?),
#	'gap_std' => standard deviation of gap size (?),
#	'contig_len' => contig sequence length,
#	'contig_start' => contig start coordinate,
#	'contig_end' => contig end coordinate,
#    }] }
#
# $annotDb - annotation database from which the scaffolds and/or assembly sequences were loaded
# $chadoDb - target chado database
# $bsmlListFile - path to a file that lists all of the assembly/contig BSML documents
# $outputDir - where to write the scaffold BSML documents
# $genus - genus of the organism to which the scaffolded sequences belong
# $species - species of the organism to which the scaffolded sequences belong
# $parseGaps - whether to parse gap sizes from input file; default is to use fixed 100 BP gap size
# $parseOnly - parse input files and run error checks but don't create any target BSML scaffold files
# $idGen - a function that returns a new supercontig uniquename every time it is called
# $elogger - any logging class that supports a get_logger() method
#
sub writeBsmlScaffoldFiles {
    my($scaffolds, $annotDb, $dbType, $chadoDb, $bsmlListFile, $outputDir,
       $genus, $species, $parseGaps, $parseOnly, $idGen, $elogger) = @_;
    
    my $logger = $elogger->get_logger(__PACKAGE__);
    my $scaffoldsSkipped = 0;
    my $scaffoldsCreated = 0;
    my $assembliesWritten = 0;

    # read $bsmlListFile into a hash
    my $asmbl2File = &readAssemblyBsmlListFromFile($bsmlListFile, $logger);
    
    # Create BSML for each scaffold, flagging those scaffolds that contain assemblies
    # not already in the target database/BSML_repository.
    foreach my $scaffold (@$scaffolds) {
	my $data = $scaffold->{'data'}; # sorted contigs
	
	# check that we have an assembly BSML document for each assembly
	my $numMissing = 0;
	my $numContigs = scalar(@$data);
	foreach my $datum (@$data) {
	    my $asmblId = $datum->{'asmbl_id'};
	    my $key = "${annotDb}.${asmblId}";
	    my $asmblBsmlFile = $asmbl2File->{$key};
	    ++$numMissing if (!defined($asmblBsmlFile));
	    $datum->{'assembly_bsml_file'} = $asmblBsmlFile;
	}
	
	if ($numMissing > 0) {
	    ++$scaffoldsSkipped;
	    $logger->warn("skipping scaffold with $numMissing/$numContigs contigs/assemblies missing");
	} else {
	    my $scaffoldSeq = '';
	    my $scaffoldSeqLen = 0;
	    my $builder = new BSML::BsmlBuilder();
	    # scaffold id from the specification file
	    my $scaffoldId = $scaffold->{'scaff_id'};

	    # TODO - store old-style scaffold id somewhere?
#	    my $oldScaffBsmlId = "${annotDb}_${scaffoldId}_supercontig";

	    # autogenerated scaffold uniquename
	    my $scaffBsmlId = &$idGen();
	    my $scaffBsmlFile = File::Spec->catdir($outputDir, "${scaffBsmlId}.bsml");

	    my $genome = $builder->createAndAddGenome();
	    my $organism = $builder->createAndAddOrganism(genome => $genome, species => $species, genus => $genus );
	    $builder->createAndAddStrain(organism => $organism, database => $chadoDb, source_database => $annotDb );
	    $builder->makeCurrentDocument();
	    my $bsmlScaffoldSeq = $builder->createAndAddExtendedSequenceN(id => $scaffBsmlId, molecule => "DNA", length => -1 );

	    ## see bug #2378
	    $builder->createAndAddLink(
				       $bsmlScaffoldSeq,
				       'genome',
				       '#'.$genome->{'attr'}->{'id'},
				       );
	    ## ^^^^^^^^^^^^^
	    $bsmlScaffoldSeq->addattr("class", "supercontig");
	    ## See bug 2692
            my $scaffoldAttrList = [{name => 'SO', content=> 'supercontig'}];
	    ## ^^^^^^^^^^^^

	    $bsmlScaffoldSeq->addBsmlAttributeList($scaffoldAttrList);
	    
	    # save chromosome name/number
	    # PLEASE NOTE: this attribute CANNOT be added to $scaffoldAttrList, because that would
	    # cause some software (e.g. bsml2chado) to interpret it as an attribute of the first
	    # element of the list, rather than as an attribute of the BSML Sequence.
	    my $chromosome = $scaffold->{'chromosome'};
	    if (defined($chromosome)) {
		$bsmlScaffoldSeq->addBsmlAttr('chromosome', $chromosome);
	    }
	    
	    my $numContigs = scalar(@$data);
	    
	    for (my $contigNum = 0;$contigNum < $numContigs;++$contigNum) {
		my $datum = $data->[$contigNum];
		my $asmblId = $datum->{'asmbl_id'};
		my $contigLen = $datum->{'contig_len'};
		my $contigStart = $datum->{'contig_start'};
		my $contigEnd = $datum->{'contig_end'};
		my $asmblBsmlId = "${annotDb}_${asmblId}_assembly";
		my $asmblBsmlFile = $datum->{'assembly_bsml_file'};

		$logger->debug("contig: $contigStart - $contigEnd asmblBsmlFile: $asmblBsmlFile");

		if ($datum->{'scaff_order'} != ($contigNum+1)) {
		    $logger->warn("gap in contig sequence number for $asmblId in $scaffoldId");
		}
		
		# read assembly document and add its sequence to the scaffold sequence
		my $reader = new BSML::BsmlReader;
		my $parser = new BSML::BsmlParserTwig;
		$reader->makeCurrentDocument();
		$parser->parse(\$reader, $asmblBsmlFile);
		my $bsmlSeq = BSML::BsmlDoc::BsmlReturnDocumentLookup($asmblBsmlId);

		# if this lookup fails then we need to check the Cross-references of every 
		# assembly sequence in the document
		if (!defined($bsmlSeq)) {
		    my $bsmlSeqList = $reader->returnAllSequences();

		    foreach my $bseq (@$bsmlSeqList) {
			my $id = $bseq->returnattr('id');

			# only interested in assembly sequences
			next unless ($id =~ /assembly/);
			my $crossRefs = $bseq->returnBsmlCrossReferenceListR();
			my $ucAnnotDb = $annotDb;
			$ucAnnotDb =~ s/^(\S)/uc($1)/e;
			my $crossRefDbName = 'TIGR_' . $ucAnnotDb;

			foreach my $cr (@$crossRefs) {
			    my($crdb, $crid) = map { $cr->returnattr($_) } ('database', 'identifier');
			    if (($crdb eq $crossRefDbName) && ($crid eq $asmblId)) {
				$bsmlSeq = $bseq;
				last;
			    }
			}
			# assembly sequence should be first, allowing use to avoid looking at the rest
			last if (defined($bsmlSeq));
		    }
		    if (defined($bsmlSeq)) {
			$asmblBsmlId = $bsmlSeq->returnattr('id');
		    } else {
			die "Unable to find BSML sequence data for asmbl_id $asmblId in $asmblBsmlFile" if (!defined($bsmlSeq));
		    }
		}

		my $revcomp = ($datum->{'direction'} eq 'R');
		my $sdi = $reader->readSequenceDatImport($bsmlSeq);
		die "readSequenceDatImport failed on bsmlSeq $bsmlSeq" if (!defined($sdi));
		my $ss = $sdi->{'seqdat'};
		my $sl = length($ss);
		$logger->warn("read 0-length sequence for $asmblBsmlId") if ($sl == 0);
		
		# compare assembly sequence length with contig length in scaffold file
		if ($contigLen != $sl) {
		    $logger->warn("actual assembly sequence length ($sl) and length from scaffold description ($contigLen) differ");
		}
		# check coordinates in scaffold file against those computed from sequences
		my $cstart = $revcomp ? $scaffoldSeqLen + $sl : $scaffoldSeqLen;
		my $cend = $revcomp ? $scaffoldSeqLen : $scaffoldSeqLen + $sl;

		if ($cstart != $contigStart) {
		    $logger->warn("actual contig start position ($cstart) and annotated start position ($contigStart) do not match");
		}
		if ($cend != $contigEnd) {
		    $logger->warn("actual contig end position ($cend) and annotated start position ($contigEnd) do not match");
		}

		# reverse complement assembly sequence if necessary, add gap characters
		$ss = &_revcomp($ss) if ($revcomp);
		
		$builder->makeCurrentDocument();
		my $asmblBsmlSeq = $builder->createAndAddExtendedSequenceN( id => $asmblBsmlId, length => $sl );
		$asmblBsmlSeq->addattr("class", "contig");
		## See bug 2692
		$asmblBsmlSeq->addBsmlAttributeList([{name => 'SO', content=> 'contig'}]);
		## ^^^^^^^^^^^^
		
		my $numbering = $builder->createAndAddNumbering( seq => $asmblBsmlSeq,
								 seqref => $scaffBsmlId,
								 refnum => $cstart,
								 ascending => $revcomp ? 0 : 1,
								 );
		
		# only add gap between adjacent sequences, not at the end (or beginning) of the scaffold
		my $contigFmax = ($contigStart >= $contigEnd) ? $contigStart : $contigEnd;
			    
		if ($contigNum < ($numContigs-1)) {
		    my $nc = $data->[$contigNum+1];
		    my $ncStart = $nc->{'contig_start'};
		    my $ncEnd = $nc->{'contig_end'};
		    my $ncFmin = ($ncStart <= $ncEnd) ? $ncStart : $ncEnd;

		    if ($parseGaps) {
			my $nGapChars = $ncFmin - $contigFmax;
			$ss .= &_makeGap($nGapChars);
			$scaffoldSeqLen += $nGapChars;
		    } else {
			$ss .= $GAP_CHARS;
			$scaffoldSeqLen += $NUM_GAP_CHARS;
		    }
		}

		$scaffoldSeq .= $ss;
		$scaffoldSeqLen += $sl;

		# NOTE - is the "_" prefix on the id meant to be there?
		$builder->createAndAddSeqDataImportN(seq => $ss, format => "BSML", source => $asmblBsmlFile, id => '_' . $asmblBsmlId);
	    }

	    if (!$parseOnly) {
		$builder->createAndAddSeqData( $bsmlScaffoldSeq, $scaffoldSeq );
		$bsmlScaffoldSeq->addattr('length', $scaffoldSeqLen);
		$builder->write($scaffBsmlFile);
	    }

	    ++$scaffoldsCreated;
	    $assembliesWritten += scalar(@$data);
	}
    }
    $logger->info("skipped $scaffoldsSkipped/" . scalar(@$scaffolds) . " scaffold(s) missing 1 or more assembly BSML files");
    $logger->info("created $scaffoldsCreated BSML scaffold document(s) containing $assembliesWritten assemblies");
    return 1;
}

# Read a file that lists the location of each assembly BSML file.
#
# $bsmlListFile   - the file to read
#
# returns a hash whose keys are of the form "dbname.asmblid" and whose values are the BSML filenames
#
sub readAssemblyBsmlListFromFile {
    my($bsmlListFile, $logger) = @_;
    my $hash = {};

    my $fh = FileHandle->new();
    $fh->open($bsmlListFile) || die "unable to read from $bsmlListFile";
    my $lnum = 0;

    while (my $line = <$fh>) {
	chomp($line);
	++$lnum;
	next if ($line =~ /^\s*$/);
	if ($line =~ /\/([a-z]+\d+)\_(\d+)\_assembly\.(prok|euk)\.bsml$/) {
	    my $db = $1;
	    my $asmblId = $2;
	    my $filename = $line;
	    if ((!-e $filename) && (!-e "$filename.gz")) {
		$logger->warn("can't find $filename");
	    }
	    $hash->{ join('.', $db, $asmblId) } = $filename;
	} else {
	    die "error - can't parse line $lnum of $bsmlListFile: '$line'";
	}
    }

    $fh->close();
    return $hash;
}

# reverse complement a sequence
sub _revcomp {
    my($seq) = @_;
    my $compseq = $seq;
    $compseq =~ tr/acgtrymkswhbvdnxACGTRYMKSWHBVDNX/tgcayrkmswdvbhnxTGCAYRKMSWDVBHNX/;
    
    my $seqlen = length($compseq);
    my $revseq = '';
    
    for(my $i = $seqlen - 1;$i >= 0;--$i) {
	my $char = substr($compseq, $i, 1);
	$revseq .= $char;
    }
    return $revseq;
}

sub _makeGap {
    my($num_ns) = @_;
    my $gap_string = '';
    # not very efficient, but fine for small-medium sized gaps:
    for( my $i=0; $i<$num_ns; $i++ ) { $gap_string .= 'N'; }
    return $gap_string;
}

1;

